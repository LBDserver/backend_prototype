"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var HttpClient = require('../http/http-client');

var ConsoleLogger = require('../logging/console-logger');

var RDFRepositoryClient = require('../repository/rdf-repository-client');

var RepositoryClientConfig = require('../repository/repository-client-config');

var HttpRequestBuilder = require('../http/http-request-builder');

var RDFMimeType = require('../http/rdf-mime-type');

var SERVICE_URL = '/repositories';
/**
 * Implementation of the RDF server operations.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */

var ServerClient =
/*#__PURE__*/
function () {
  /**
   * @param {ServerClientConfig} config for the server client.
   **/
  function ServerClient(config) {
    _classCallCheck(this, ServerClient);

    this.config = config;
    this.initHttpClient();
    this.initLogger();
  }
  /**
   * Get an array of repository ids available in the server.
   * @return {Promise} promise which resolves with an Array with repository ids.
   */


  _createClass(ServerClient, [{
    key: "getRepositoryIDs",
    value: function getRepositoryIDs() {
      var _this = this;

      var requestBuilder = HttpRequestBuilder.httpGet(SERVICE_URL).addAcceptHeader(RDFMimeType.SPARQL_RESULTS_JSON);
      var elapsedTime = Date.now();
      return this.httpClient.request(requestBuilder).then(function (response) {
        elapsedTime = Date.now() - elapsedTime;

        _this.logger.debug({
          elapsedTime: elapsedTime
        }, 'Retrieved repository IDs');

        return response.data.results.bindings.map(function (_ref) {
          var id = _ref.id;
          return id.value;
        });
      });
    }
    /**
     * Check if repository with the provided id exists.
     * @param {string} id of the repository which should be checked.
     * @return {Promise<boolean>} promise which resolves with boolean value.
     */

  }, {
    key: "hasRepository",
    value: function hasRepository(id) {
      if (!id) {
        throw new Error('Repository id is required parameter!');
      }

      return this.getRepositoryIDs().then(function (repositoryIds) {
        return repositoryIds.indexOf(id) !== -1;
      });
    }
    /**
     * Creates a repository client instance with the provided id and
     * configuration.
     * @param {string} id of the repository
     * @param {RepositoryClientConfig} config for the overridable repository
     *    configuration.
     * @return {Promise<RDFRepositoryClient>} promise which resolves with
     *    new RDFRepositoryClient instance.
     */

  }, {
    key: "getRepository",
    value: function getRepository(id, config) {
      var _this2 = this;

      if (!id) {
        throw new Error('Repository id is required parameter!');
      }

      if (!config || !(config instanceof RepositoryClientConfig)) {
        throw new Error('RepositoryClientConfig is required parameter!');
      }

      return this.hasRepository(id).then(function (exists) {
        if (exists) {
          return new RDFRepositoryClient(config);
        }

        _this2.logger.error({
          repoId: id
        }, 'Repository does not exist');

        return Promise.reject(new Error("Repository with id ".concat(id, " does not exists.")));
      });
    }
    /**
     * Delete repository with the provided id.
     * @param {string} id of the repository which should be deleted.
     * @return {Promise<any>} promise which resolves with the delete result.
     */

  }, {
    key: "deleteRepository",
    value: function deleteRepository(id) {
      var _this3 = this;

      if (!id) {
        throw new Error('Repository id is required parameter!');
      }

      var requestBuilder = HttpRequestBuilder.httpDelete("".concat(SERVICE_URL, "/").concat(id));
      var elapsedTime = Date.now();
      return this.httpClient.request(requestBuilder).then(function () {
        elapsedTime = Date.now() - elapsedTime;

        _this3.logger.info({
          repoId: id,
          elapsedTime: elapsedTime
        }, 'Deleted repository');
      });
    }
    /**
     * Initializes the http client.
     */

  }, {
    key: "initHttpClient",
    value: function initHttpClient() {
      this.httpClient = new HttpClient(this.config.getEndpoint()).setDefaultReadTimeout(this.config.getTimeout()).setDefaultWriteTimeout(this.config.getTimeout());
    }
    /**
     * Initializes the logger.
     */

  }, {
    key: "initLogger",
    value: function initLogger() {
      this.logger = new ConsoleLogger({
        name: 'ServerClient',
        serverURL: this.config.getEndpoint()
      });
    }
  }]);

  return ServerClient;
}();

module.exports = ServerClient;