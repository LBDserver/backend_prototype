/**
 * Instantiates new HTTP client with the supplied base URL and default
 * request timeouts.
 *
 * @constructor
 * @param {string} baseURL base URL that will be prepend to all requests
 * GET
 */
declare class HttpClient {
    constructor(baseURL: string);
    /**
     * Sets the provided header map as default for all requests.
     *
     * Any additional headers provided in the request configuration will
     * be merged with this default map.
     *
     * @param {Map<string, string>} headers map with default headers
     * @return {HttpClient} the current client for method chaining
     */
    setDefaultHeaders(headers: Map<string, string>): HttpClient;
    /**
     * Sets the default request read timeout. It will be used in case requests
     * don't explicitly specify it in their request configurations.
     *
     * @param {number} readTimeout the default read timeout
     * @return {HttpClient} the current client for method chaining
     */
    setDefaultReadTimeout(readTimeout: number): HttpClient;
    /**
     * Sets the default request write timeout. It will be used in case requests
     * don't explicitly specify it in their request configurations.
     *
     * @param {number} writeTimeout the default write timeout
     * @return {HttpClient} the current client for method chaining
     */
    setDefaultWriteTimeout(writeTimeout: number): HttpClient;
    /**
     * Performs HTTP request using the supplied request builder.
     *
     * @param {HttpRequestBuilder} requestBuilder
     * @return {Promise<any>} a promise resolving to the request's response
     */
    request(requestBuilder: HttpRequestBuilder): Promise<any>;
    /**
     * Returns the base URL which this http client uses to send requests.
     *
     * @return {string} the base URL for each request
     */
    getBaseURL(): string;
}

/**
 * Does default initialization of the configuration.
 */
declare class HttpRequestBuilder {
    /**
     * Prepares new builder for HTTP GET request against the provided URL.
     *
     * @static
     * @param {string} url
     * @return {HttpRequestBuilder}
     */
    static httpGet(url: string): HttpRequestBuilder;
    /**
     * Prepares new builder for HTTP POST request against the provided URL.
     *
     * @static
     * @param {string} url
     * @return {HttpRequestBuilder}
     */
    static httpPost(url: string): HttpRequestBuilder;
    /**
     * Prepares new builder for HTTP PUT request against the provided URL.
     *
     * @static
     * @param {string} url
     * @return {HttpRequestBuilder}
     */
    static httpPut(url: string): HttpRequestBuilder;
    /**
     * Prepares new builder for HTTP DELETE request against the provided URL.
     *
     * @static
     * @param {string} url
     * @return {HttpRequestBuilder}
     */
    static httpDelete(url: string): HttpRequestBuilder;
    /**
     * Add a new http header entry. Blank values are skipped.
     *
     * @param {string} header type
     * @param {string} value the header value
     * @return {HttpRequestBuilder}
     */
    addHeader(header: string, value: string): HttpRequestBuilder;
    /**
     * Sets the headers map.
     *
     * @param {Object<string, string>} headers the headers map
     * @return {HttpRequestBuilder}
     */
    setHeaders(headers: {
        [key: string]: string;
    }): HttpRequestBuilder;
    /**
     * Returns the headers map.
     *
     * @return {Object<string, string>}
     */
    getHeaders(): {
        [key: string]: string;
    };
    /**
     * Add a specific header of type <code>Accept</code> with the given value.
     *
     * @param {string} value
     * @return {HttpRequestBuilder}
     */
    addAcceptHeader(value: string): HttpRequestBuilder;
    /**
     * Add a specific header of type <code>Content-Type</code> with the given
     * value.
     *
     * @param {string} value
     * @return {HttpRequestBuilder}
     */
    addContentTypeHeader(value: string): HttpRequestBuilder;
    /**
     * Set request parameters object.
     *
     * @param {Object} params
     * @return {HttpRequestBuilder}
     */
    setParams(params: any): HttpRequestBuilder;
    /**
     * Add a new request param.
     *
     * @param {string} param
     * @param {*} value
     * @return {HttpRequestBuilder}
     */
    addParam(param: string, value: any): HttpRequestBuilder;
    /**
     * Returns the request parameters map.
     *
     * @return {Object<string, *>}
     */
    getParams(): {
        [key: string]: any;
    };
    /**
     * Set timeout configuration.
     *
     * @param {number} timeout in ms
     * @return {HttpRequestBuilder}
     */
    setTimeout(timeout: number): HttpRequestBuilder;
    /**
     * Returns the request timeout.
     *
     * @return {number}
     */
    getTimeout(): number;
    /**
     * Set a responseType config.
     *
     * @param {string} responseType
     * @return {HttpRequestBuilder}
     */
    setResponseType(responseType: string): HttpRequestBuilder;
    /**
     * Returns the request's response type.
     *
     * @return {string}
     */
    getResponseType(): string;
    /**
     * Sets the data to be sent as request payload.
     *
     * @param {*} data the payload
     * @return {HttpRequestBuilder}
     */
    setData(data: any): HttpRequestBuilder;
    /**
     * Gets the data to be sent as payload.
     *
     * @return {*}
     */
    getData(): any;
    /**
     * Sets the URL against which to perform the request.
     *
     * @param {string} url
     * @return {HttpRequestBuilder}
     */
    setUrl(url: string): HttpRequestBuilder;
    /**
     * Gets the URL.
     *
     * @return {string}
     */
    getUrl(): string;
    /**
     * Sets the HTTP method.
     *
     * @param {string} method
     * @return {HttpRequestBuilder}
     */
    setMethod(method: string): HttpRequestBuilder;
    /**
     * Gets the HTTP method.
     *
     * @return {string}
     */
    getMethod(): string;
    /**
     * Getter for the configuration.
     * @return {Object}
     */
    get(): any;
}

/**
 * Constructs new wrapper with the supplied response and client.
 * @param {AxiosResponse} response the HTTP response
 * @param {HttpClient} httpClient client that performed the HTTP request
 */
declare class HttpResponse {
    constructor(response: AxiosResponse, httpClient: HttpClient);
    /**
     * Returns the HTTP response's data.
     *
     * @return {string|any} the response data
     */
    getData(): string | any;
    /**
     * Returns the HTTP response's headers.
     *
     * @return {{object}} the headers map
     */
    getHeaders(): any;
    /**
     * Sets the elapsed time of the request and response.
     *
     * @param {number} elapsedTime the elapsed time in milliseconds
     */
    setElapsedTime(elapsedTime: number): void;
    /**
     * Returns the elapsed time of the HTTP request execution.
     *
     * @return {number} the elapsed time in milliseconds
     */
    getElapsedTime(): number;
    /**
     * Returns the base URL to which this request was performed.
     *
     * @return {string} the base URL
     */
    getBaseURL(): string;
}

/**
 * Supported query content types.
 *
 * @readonly
 * @enum {string}
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare const enum QueryContentType {
    X_WWW_FORM_URLENCODED = "application/x-www-form-urlencoded",
    SPARQL_UPDATE = "application/sparql-update",
    SPARQL_QUERY = "application/sparql-query"
}

/**
 * Supported RDF mime types.
 *
 * @readonly
 * @enum {string}
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare const enum RDFMimeType {
    RDF_XML = "application/rdf+xml",
    N_TRIPLES = "text/plain",
    TURTLE = "text/turtle",
    N3 = "text/rdf+n3",
    N_QUADS = "text/x-nquads",
    JSON_LD = "application/ld+json",
    RDF_JSON = "application/rdf+json",
    TRIX = "application/trix",
    TRIG = "application/x-trig",
    BINARY_RDF = "application/x-binary-rdf",
    SPARQL_RESULTS_XML = "application/sparql-results+xml",
    SPARQL_RESULTS_JSON = "application/sparql-results+json",
    BINARY_RDF_RESULTS_TABLE = "application/x-binary-rdf-results-table",
    BOOLEAN_RESULT = "text/boolean"
}

/**
 * Initializes a console logger.
 *
 * Allows to create a child logger by providing the <code>config</code> param.
 * Anything in this configuration will be appended for each log.
 *
 * @param {object} [config] optional child logger configuration
 */
declare class ConsoleLogger {
    constructor(config?: any);
    /**
     * Logs an info message.
     *
     * @param {...object} args arguments to be relayed for logging
     */
    info(...args: any[]): void;
    /**
     * Logs a warn message.
     *
     * @param {...object} args arguments to be relayed for logging
     */
    warn(...args: any[]): void;
    /**
     * Logs an error message.
     *
     * @param {...object} args arguments to be relayed for logging
     */
    error(...args: any[]): void;
    /**
     * Logs a debug message.
     *
     * @param {...object} args arguments to be relayed for logging
     */
    debug(...args: any[]): void;
    /**
     * Logs a trace message.
     *
     * @param {...object} args arguments to be relayed for logging
     */
    trace(...args: any[]): void;
}

/**
 * Interface defining the API for logging implementations.
 *
 * @interface
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare interface Logger {
}

/**
 * Utilities related to logging.
 *
 * @author Mihail Radkov
 */
declare class LoggingUtils {
    /**
     * Creates an object from the provided HTTP response that is suitable for
     * structured logging.
     *
     * Any additional key-value entries from <code>params</code> will be assigned
     * in the created payload object.
     *
     * @protected
     * @param {HttpResponse} response the HTTP response.
     * Used to get the execution time and the base URL
     * @param {object} [params] additional parameters to be appended
     * @return {object} the constructed payload object for logging
     */
    protected static getLogPayload(response: HttpResponse, params?: any): any;
}

/**
 * Instantiates a namespace with its prefix.
 *
 * @param {string} prefix the namespace prefix
 * @param {NamedNode} namespace the namespace as named node
 */
declare class Namespace {
    constructor(prefix: string, namespace: NamedNode);
    /**
     * Returns the namespace prefix.
     *
     * @return {string} the namespace prefix
     */
    getPrefix(): string;
    /**
     * Returns the namespace.
     *
     * @return {NamedNode} the namespace as named node
     */
    getNamespace(): NamedNode;
}

/**
 * Utility class for converting strings to terms, terms to quads and
 * quads to string according to the {@link https://rdf.js.org} specification.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class TermConverter {
    /**
     * Convert the supplied params to a collection of quads.
     *
     * The produced quads size depends on the supplied amount of context.
     *
     * @public
     * @static
     * @param {string} subject the quad's subject
     * @param {string} predicate the quad's predicate
     * @param {string} object the quad's object
     * @param {(string|string[])} [contexts] the quad's context
     * @return {Quad[]} a collection of quads constructed from the provided params
     */
    public static getQuads(subject: string, predicate: string, object: string, contexts?: string | string[]): Quad[];
    /**
     * Convert the supplied params to a collection of quads.
     *
     * The quads object term will be a literal with a data type or a language.
     *
     * The produced quads size depends on the supplied amount of context.
     *
     * @public
     * @static
     * @param {string} subject the quad's subject
     * @param {string} predicate the quad's predicate
     * @param {string} object the quad's object
     * @param {(string|string[])} [contexts] the quad's context
     * @param {string} type the quad's data type
     * @param {string} language the quad's literal language
     * @return {Quad[]} a collection of quads constructed from the provided params
     */
    public static getLiteralQuads(subject: string, predicate: string, object: string, contexts?: string | string[], type: string, language: string): Quad[];
    /**
     * Serializes the provided collection of quads to Turtle format or Trig in
     * case any of the quads have context.
     *
     * @public
     * @static
     * @param {Quad[]} quads the collection of quads to serialize to Turtle
     * @return {string} a promise that will be resolved to Turtle or Trig
     * text or rejected if the quads cannot be serialized
     */
    public static toString(quads: Quad[]): string;
    /**
     * Converts the provided value to N-Triple encoded value in case it is not
     * already one or a literal value.
     *
     * For example:
     * <ul>
     *   <li><i>http://resource</i> encodes to <i><http://resource></i></li>
     *   <li><i>"Literal title"@en</i> will not be encoded</li>
     *   <li><i><http://resource></i> encodes to the same value</li>
     * </ul>
     *
     * Empty or null values are ignored.
     *
     * @public
     * @static
     * @param {string} value the value for converting
     * @return {string} the converted value to N-Triple
     */
    public static toNTripleValue(value: string): string;
    /**
     * Converts the provided values to N-Triple encoded values in case they are
     * not already one or literal values.
     *
     * Empty or null values are ignored.
     *
     * @see {@link #toNTripleValue}
    
     * @public
     * @static
     * @param {string|string[]} values the values for converting
     * @return {string|string[]} the converted value or values to N-Triple
     */
    public static toNTripleValues(values: string | string[]): string | string[];
}

/**
 * Data types from the XSD schema.
 *
 * @readonly
 * @enum {string}
 *
 * @author Mihail Radkov
 */
declare const enum XSD {
    INTEGER = "xsd:integer",
    DECIMAL = "xsd:decimal",
    STRING = "xsd:string",
    BOOLEAN = "xsd:boolean"
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class ContentParser {
    constructor(config: any);
    /**
     * @return {Object} config is the passed during the initialization parser
     * config object.
     */
    getConfig(): any;
    /**
     * If implemented by successors, this must return boolean <code>true</code>
     * when the wrapped parser supports stream reading by default or
     * <code>false</code> otherwise.
     *
     * @abstract
     * @return {boolean} if the parser supports streaming by default
     */
    isStreaming(): boolean;
    /**
     * Implementations should delegate the actual parsing to underlying parser
     * library or to a custom implementation.
     *
     * @abstract
     * @param {string} content which has to be parsed to given format.
     * @param {Object} [config] optional parser configuration.
     * @return {Term} the converted content.
     */
    parse(content: string, config?: any): Term;
    /**
     * @abstract
     * @return {string} the type which underlying parser supports which should be
     * the type under which it was registered in the parser registry.
     */
    getSupportedType(): string;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class JsonLDParser {
    constructor(config: any);
    /**
     * @inheritDoc
     */
    parse(): void;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
    /**
     * @inheritDoc
     */
    isStreaming(): void;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class NQuadsParser {
    constructor(config: any);
    /**
     * @inheritDoc
     */
    parse(): void;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class NTriplesParser {
    constructor(config: any);
    /**
     * @inheritDoc
     */
    parse(): void;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class N3Parser {
    constructor(config: any);
    /**
     * @inheritDoc
     */
    parse(): void;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
}

/**
 * @param {ContentParser[]} [parsers] initialized list with valid parser
 * instances.
 */
declare class ParserRegistry {
    constructor(parsers?: ContentParser[]);
    /**
     * Initializes a console logger.
     */
    initLogger(): void;
    /**
     * Register provided {@link ContentParser} under given key as returned by
     * <code>parser.getSupportedType()</code>.
     * If the type of the provided parser is already registered, then this method
     * will override the registered parser with the provided instance.
     *
     * @param {ContentParser} parser implementation wrapper.
     */
    register(parser: ContentParser): void;
    /**
     * Getter for parser of given type.
     *
     * @param {string} type of the parser for get.
     * @return {ContentParser} if parser of requested type is found or
     * <code>null</code> otherwise.
     */
    get(type: string): ContentParser;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class RDFXmlParser {
    constructor(config: any);
    /**
     * @inheritDoc
     */
    parse(): void;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
    /**
     * @inheritDoc
     */
    isStreaming(): void;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class SparqlJsonResultParser {
    constructor(config: any);
    /**
     * This method should be invoked with a text stream and will return also a
     * stream converted to RDFJS objects.
     *
     * Client of the method can subscribe to following events in order to consume
     * the stream:
     * <code>
     * stream.on('variables', (variables) => console.log(variables));
     * stream.on('data', (bindings) => console.log(bindings));
     * stream.on('error', (error) => console.log(error));
     * </code>
     *
     * @param {NodeJS.ReadableStream} stream with the text which has to be parsed
     * to given format.
     * @param {Object} [config] optional parser configuration.
     * @return {NodeJS.ReadableStream|Promise<boolean>} a stream with the
     * converted content for SELECT queries and a Promise which resolves to
     * boolean value for ASK queries.
     */
    parse(stream: NodeJS.ReadableStream, config?: any): NodeJS.ReadableStream | Promise<boolean>;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
    /**
     * @inheritDoc
     */
    isStreaming(): void;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class SparqlXmlResultParser {
    constructor(config: any);
    /**
     * This method should be invoked with a text stream and will return also a
     * stream converted to RDFJS objects.
     *
     * Client of the method can subscribe to following events in order to consume
     * the stream:
     * <code>
     * stream.on('variables', (variables) => console.log(variables));
     * stream.on('data', (bindings) => console.log(bindings));
     * stream.on('error', (error) => console.log(error));
     * </code>
     *
     * @param {NodeJS.ReadableStream} stream with the text which has to be parsed
     * to given format.
     * @param {Object} [config] optional parser configuration.
     * @return {NodeJS.ReadableStream|Promise<boolean>} a stream with the
     * converted content for SELECT queries and a Promise which resolves to
     * boolean value for ASK queries.
     */
    parse(stream: NodeJS.ReadableStream, config?: any): NodeJS.ReadableStream | Promise<boolean>;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
    /**
     * @inheritDoc
     */
    isStreaming(): void;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class TriGParser {
    constructor(config: any);
    /**
     * @inheritDoc
     */
    parse(): void;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
}

/**
 * @param {Object} config is an object containing the parser configuration.
 */
declare class TurtleParser {
    constructor(config: any);
    /**
     * @inheritDoc
     */
    parse(): void;
    /**
     * @inheritDoc
     */
    getSupportedType(): void;
}

/**
 * Does basic initialization.
 */
declare class GetQueryPayload {
    /**
     * @param {string} query The query as string to be evaluated.
     * @return {UpdateQueryPayload}
     * @throws {Error} if the query is not a string
     */
    setQuery(query: string): UpdateQueryPayload;
    /**
     * @return {string} a query which was populated in the payload.
     */
    getQuery(): string;
    /**
     * @param {string} [queryLn] the query language that is used for the query.
     * @return {GetQueryPayload}
     * @throws {Error} if the query language is not one of {@link QueryLanguage}
     */
    setQueryLn(queryLn?: string): GetQueryPayload;
    /**
     * Populates an optional $key:value binding in the payload. Existing bindings
     * will be overridden.
     *
     * @param {string} [binding] A variable binding name which may appear in the
     *                 query and can be bound to a specific value provided outside
     *                 of the actual query.
     * @param {string} [value] A variable's binding value. See the binding comment
     * @return {GetQueryPayload}
     * @throws {Error} if the binding or the value is not a string
     */
    addBinding(binding?: string, value?: string): GetQueryPayload;
    /**
     * @param {boolean} [distinct] Specifies if only distinct query solutions
     *                  should be returned.
     * @return {GetQueryPayload}
     * @throws {Error} if the parameter is not a boolean
     */
    setDistinct(distinct?: boolean): GetQueryPayload;
    /**
     * @param {number} limit specifies the maximum number of query solutions to
     *                 return.
     * @return {GetQueryPayload}
     * @throws {Error} if the limit is not a non negative number
     */
    setLimit(limit: number): GetQueryPayload;
    /**
     * @param {number} [offset] Specifies the number of query solutions to skip.
     * @return {GetQueryPayload}
     * @throws {Error} if the offset is not a non negative number
     */
    setOffset(offset?: number): GetQueryPayload;
    /**
     * @inheritDoc
     * @throws {Error} if the validation does not pass
     */
    validateParams(): void;
    /**
     * A mandatory parameter which is used for resolving the Accept http header
     * required by the RDF store.
     *
     * @param {string} responseType
     * @return {GetQueryPayload}
     * @throws {Error} if the response type is not one of {@link RDFMimeType}
     */
    setResponseType(responseType: string): GetQueryPayload;
    /**
     * @return {string} response type which was populated in this payload.
     */
    getResponseType(): string;
    /**
     * A mandatory parameter used for resolving request headers and resolving
     * the response parsers.
     *
     * @param {QueryType} queryType
     * @return {GetQueryPayload}
     * @throws {Error} if the query type is not one of {@link QueryType}
     */
    setQueryType(queryType: QueryType): GetQueryPayload;
    /**
     * @return {string} query type which was populated in this payload. The value
     * is one of the {@link QueryType} enum values.
     */
    getQueryType(): string;
    /**
     * @inheritDoc
     */
    getSupportedContentTypes(): void;
}

/**
 * Supported query languages.
 *
 * @readonly
 * @enum {string}
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare const enum QueryLanguage {
    SPARQL = "sparql",
    SERQL = "serql"
}

/**
 * Does basic initialization.
 */
declare class QueryPayload {
    /**
     * @param {boolean} [inference] Specifies whether inferred statements should
     *                  be included in the query evaluation.
     * @return {QueryPayload}
     */
    setInference(inference?: boolean): QueryPayload;
    /**
     * @param {number} [timeout] Specifies a maximum query execution time, in
     *                 whole seconds.
     * @return {QueryPayload}
     */
    setTimeout(timeout?: number): QueryPayload;
    /**
     * An optional parameter which is used for defining the request Content-Type.
     *
     * @param {string} [contentType] One of the supported content types for given
     * operation.
     * @return {QueryPayload}
     */
    setContentType(contentType?: string): QueryPayload;
    /**
     * @return {string} content type which was populated in this payload.
     */
    getContentType(): string;
    /**
     * Serializes all query parameters populated in the payload. Only parameters
     * which are present will be returned.
     *
     * Mandatory and dependent parameters are validated and errors are thrown if
     * necessary.
     *
     * @return {string} a serialized payload which holds all available query
     * parameters in this payload object.
     */
    getParams(): string;
    /**
     * Utility method which serializes a single level json object to properly
     * encoded string that can be used in a request.
     *
     * @protected
     * @param {Object} data object which holds request parameter key:value pairs.
     * @return {string} provided object serialized and encoded to string.
     */
    protected serialize(data: any): string;
    /**
     * Must be implemented in successors.
     *
     * Validates payload for mandatory and invalid parameters.
     *
     * @abstract
     * @protected
     *
     * @return {boolean} <code>true</code> if parameters are valid and
     * <code>false</code> otherwise.
     */
    protected validateParams(): boolean;
    /**
     * Must be implemented in successors and should return a list with supported
     * content types.
     * @abstract
     * @protected
     *
     * @return {Array<string>}
     */
    protected getSupportedContentTypes(): string[];
}

/**
 * Supported RDF query types.
 *
 * @readonly
 * @enum {string}
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare const enum QueryType {
    SELECT = "SELECT",
    CONSTRUCT = "CONSTRUCT",
    DESCRIBE = "DESCRIBE",
    ASK = "ASK"
}

/**
 * Constructs this payload class.
 */
declare class UpdateQueryPayload {
    /**
     * @param {string} query The query as string to be evaluated.
     * @return {UpdateQueryPayload}
     */
    setQuery(query: string): UpdateQueryPayload;
    /**
     * @return {string} a query which was populated in the payload.
     */
    getQuery(): string;
    /**
     * One or more named graph URIs to be used as default graph(s) for retrieving.
     * @param {(string|string[])} [defaultGraphs]
     * @return {UpdateQueryPayload}
     */
    setDefaultGraphs(defaultGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @return {(string|string[])} Default graphs for the query for retrieving.
     */
    getDefaultGraphs(): string | string[];
    /**
     * One or more named graph URIs to be used as named graph(s) for retrieving.
     * @param {(string|string[])} [namedGraphs]
     * @return {UpdateQueryPayload}
     */
    setNamedGraphs(namedGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @return {(string|string[])} Named graphs set for the query for retrieving.
     */
    getNamedGraphs(): string | string[];
    /**
     * One or more default graphs for removing statements.
     * @param {(string|string[])} [removeGraphs]
     * @return {UpdateQueryPayload}
     */
    setRemoveGraphs(removeGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @return {(string|string[])} Default graphs set for the query for removing.
     */
    getRemoveGraphs(): string | string[];
    /**
     * One or more default graphs for inserting statements.
     * @param {(string|string[])} [insertGraphs]
     * @return {UpdateQueryPayload}
     */
    setInsertGraphs(insertGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @return {(string|string[])} Default graphs set for the query for inserting.
     */
    getInsertGraphs(): string | string[];
    /**
     * @inheritDoc
     */
    validateParams(): void;
    /**
     * @inheritDoc
     */
    getSupportedContentTypes(): void;
}

/**
 * Object builder used for constructing a statement addition payload.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class AddStatementPayload {
    /**
     * Sets the language this statement's object.
     *
     * This makes the statement a literal.
     *
     * @param {string} [language] the object's language
     * @return {AddStatementPayload} the payload for method chaining
     */
    setLanguage(language?: string): AddStatementPayload;
    /**
     * Returns the statement object's language.
     *
     * Having a language means it is a literal.
     *
     * @return {string} the language
     */
    getLanguage(): string;
    /**
     * Sets the data type this statement's object.
     *
     * This makes the statement a literal.
     *
     * @param {string} [dataType] the object's data type
     * @return {AddStatementPayload} the payload for method chaining
     */
    setDataType(dataType?: string): AddStatementPayload;
    /**
     * Returns the statement object's data type.
     *
     * Having a data type means it is a literal.
     *
     * @return {string} the data type
     */
    getDataType(): string;
    /**
     * Sets the statement's object value making it a literal.
     *
     * If the data type is not provided, it will try to autodetect it:
     * <ul>
     *   <li>integer -> xsd:integer</li>
     *   <li>float -> xsd:decimal</li>
     *   <li>boolean -> xsd:boolean</li>
     * </ul>
     * Everything else will be considered as xsd:string.
     *
     * To set a language the data type must be xsd:string.
     *
     * @param {*} value the statements object value
     * @param {string} [type] the statements object data type
     * @param {string} [language] the statements object language
     * @return {AddStatementPayload} the payload for method chaining
     */
    setObjectLiteral(value: any, type?: string, language?: string): AddStatementPayload;
    /**
     * Returns if this statement payload is for a literal. A literal have
     * data type and/or language.
     *
     * @return {boolean} <code>true</code> if it is a literal payload or
     * <code>false</code> otherwise
     */
    isLiteral(): boolean;
    /**
     * Sets the base URI that is used for resolving any relative URIs in the
     * current payload.
     *
     * @param {string} baseURI the base URI
     * @return {AddStatementPayload} the payload for method chaining
     */
    setBaseURI(baseURI: string): AddStatementPayload;
    /**
     * Returns the base URI that is used for resolving any relative URIs.
     *
     * @return {string} the base URI
     */
    getBaseURI(): string;
}

/**
 * Set of HTTP status codes for which requests could be re-attempted.
 *
 * @type {number[]}
 */
declare const RETRIABLE_STATUSES: number[];

/**
 * Constructs a repository client with the provided configuration.
 *
 * @param {RepositoryClientConfig} repositoryClientConfig
 */
declare class BaseRepositoryClient {
    constructor(repositoryClientConfig: RepositoryClientConfig);
    /**
     * Gets a logger instance.
     *
     * @return {Logger} the logger instance
     */
    getLogger(): Logger;
    /**
     * Register provided parser in the internal parser registry.
     *
     * @param {ContentParser} parser implementation wrapper.
     */
    registerParser(parser: ContentParser): void;
    /**
     * Parses provided content with registered parser if there is one. Otherwise
     * returns the content untouched. If <code>contentType</code> is provided it
     * should be an instance of {@link RDFMimeType} enum and is used as a key
     * for selecting appropriate parser from the parsers registry.
     * Parsing is done synchronously!
     *
     * @protected
     * @param {string} content
     * @param {string} responseType
     * @param {Object} [parserConfig] optional parser configuration
     * @return {(string|Term|Term[])}
     */
    protected parse(content: string, responseType: string, parserConfig?: any): string | Term | Term[];
    /**
     * Executor for http requests. It passes the provided HTTP request builder
     * to a HTTP client for executing requests.
     *
     * If the request was unsuccessful it will be retried with another endpoint
     * HTTP client in case the request's status is one of
     * {@link RETRIABLE_STATUSES} or if the host is currently unreachable.
     *
     * If all of the endpoints are unsuccessful then the execution will fail
     * with promise rejection.
     *
     * @protected
     * @param {HttpRequestBuilder} requestBuilder the http request data to be
     * passed to a http client
     * @return {Promise<HttpResponse|Error>} a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */
    protected execute(requestBuilder: HttpRequestBuilder): Promise<HttpResponse | Error>;
    /**
     * Creates an object from the provided HTTP response that is suitable for
     * structured logging.
     *
     * Any additional key-value entries from <code>params</code> will be assigned
     * in the created payload object.
     *
     * @protected
     * @param {HttpResponse} response the HTTP response.
     * Used to get the execution time and the base URL
     * @param {object} [params] additional parameters to be appended
     * @return {object} the constructed payload object for logging
     */
    protected getLogPayload(response: HttpResponse, params?: any): any;
}

/**
 * Constructs this payload class populating some reasonable defaults.
 */
declare class GetStatementsPayload {
    /**
     * @param {boolean} [inference] defines if inferred statements should be
     *      included in the result of GET requests.
     * @return {GetStatementsPayload}
     */
    setInference(inference?: boolean): GetStatementsPayload;
    /**
     * @return {boolean} inference
     */
    getInference(): boolean;
    /**
     * Sets responseType parameter.
     * @param {RDFMimeType} [responseType]
     * @return {GetStatementsPayload}
     */
    setResponseType(responseType?: RDFMimeType): GetStatementsPayload;
    /**
     * @return {string} responseType
     */
    getResponseType(): string;
}

/**
 * @param {RepositoryClientConfig} repositoryClientConfig
 */
declare class RDFRepositoryClient {
    constructor(repositoryClientConfig: RepositoryClientConfig);
    /**
     * @inheritDoc
     */
    getLogger(): void;
    /**
     * Instantiates dependent services.
     */
    initServices(): void;
    /**
     * Retrieves the size of the repository.
     *
     * Effectively returns how much statements are in the repository.
     *
     * If one or multiple context are provided, the operation will be restricted
     * upon each of them.
     *
     * @param {string|string[]} [context] context or contexts to restrict the
     * size calculation. Will be encoded as N-Triple if it is not already one
     * @return {Promise<number>} a promise resolving to the total number of
     *                           statements in the repository
     */
    getSize(context?: string | string[]): Promise<number>;
    /**
     * Retrieves all present namespaces as a collection of {@link Namespace}.
     *
     * @return {Promise<Namespace[]>} promise resolving to a collection of
     *                                {@link Namespace}
     */
    getNamespaces(): Promise<Namespace[]>;
    /**
     * Retrieves the namespace for the given prefix as {@link NamedNode}.
     *
     * For example if <code>rdfs</code> is provided as prefix that would result in
     * a {@link NamedNode} corresponding to following namespace:
     * <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     *
     * @param {string} prefix prefix of the namespace to be retrieved
     * @return {Promise<NamedNode>} promise resolving to {@link NamedNode}
     * @throws {Error} if the prefix parameter is not supplied
     */
    getNamespace(prefix: string): Promise<NamedNode>;
    /**
     * Creates or updates the namespace for the given prefix.
     *
     * If the provided prefix or namespace parameter is not a string or
     * {@link NamedNode} then the method will throw an error.
     *
     * @param {string} prefix prefix of the namespace to be created/updated
     * @param {string|NamedNode} namespace the namespace to be created/updated
     * @return {Promise<void>} promise that will be resolved if the create/update
     * request is successful
     * @throws {Error} if the prefix or namespace parameter are not provided
     */
    saveNamespace(prefix: string, namespace: string | NamedNode): Promise<void>;
    /**
     * Deletes a namespace that corresponds to the given prefix.
     *
     * For example if <code>rdfs</code> is provided as prefix that would delete
     * the following namespace: <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     *
     * @param {string} prefix prefix of the namespace to be deleted
     * @return {Promise<void>} promise that will be resolved if the deletion is
     * successful
     * @throws {Error} if the prefix parameter is not provided
     */
    deleteNamespace(prefix: string): Promise<void>;
    /**
     * Deletes all namespace declarations in the repository.
     *
     * @return {Promise<void>} promise that will be resolved after
     * successful deletion
     */
    deleteNamespaces(): Promise<void>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding the request
     * parameters.
     * @return {Promise<string|Quad>} resolves with plain string or Quad according
     *      to provided response type.
     */
    get(payload: GetStatementsPayload): Promise<string | Quad>;
    /**
     * Executes request to query a repository.
     *
     * Only POST request with a valid QueryPayload is supported.
     *
     * @param {GetQueryPayload} payload is an object holding request parameters
     * required by the query POST endpoint.
     * @return {Promise} the client can subscribe to the stream events and consume
     * the emitted strings or Quads depending on the provided response type as
     * soon as they are available.
     * @throws {Error} if the payload is misconfigured
     */
    query(payload: GetQueryPayload): Promise;
    /**
     * Executes a request with a sparql query against <code>/statements</code>
     * endpoint to update repository data.
     *
     * If <code>contentType</code> is set to
     * <code>application/x-www-form-urlencoded</code> then query and request
     * parameters from the payload are encoded as query string and sent as request
     * body.
     *
     * If <code>contentType</code> is set to
     * <code>application/sparql-update</code> then the query is sent unencoded as
     * request body.
     *
     * @param {UpdateQueryPayload} payload
     * @return {Promise<void>} promise that will be resolved if the update is
     * successful or rejected in case of failure
     * @throws {Error} if the payload is misconfigured
     */
    update(payload: UpdateQueryPayload): Promise<void>;
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     *
     * @param {AddStatementPayload} payload holding request parameters
     * @return {Promise<void>} promise that will be resolved if the addition is
     * successful or rejected in case of failure
     * @throws {Error} if the payload is not provided or the payload has null
     * subject, predicate and/or object
     */
    add(payload: AddStatementPayload): Promise<void>;
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle/Trig text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     * @return {Promise<void>} promise that will be resolved if the addition is
     * successful or rejected in case of failure
     */
    addQuads(quads: Quad[], context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Overwrites the repository's data by serializing the provided quads to
     * Turtle format and sending them to the repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * The overwrite will be restricted if the context parameter is specified.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle/Trig text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     * @return {Promise<void>} promise that will be resolved if the overwrite is
     * successful or rejected in case of failure
     */
    putQuads(quads: Quad[], context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Deletes statements in the repository based on the provided subject,
     * predicate, object and or contexts. Each of them is optional and acts as
     * statements filter which effectively narrows the scope of the deletion.
     *
     * Providing context or contexts will restricts the operation to one or more
     * specific contexts in the repository.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     *
     * @param {String} [subject] resource subject
     * @param {String} [predicate] resource predicate
     * @param {String} [object] resource object
     * @param {String[]|String} [contexts] resource or resources context
     * @return {Promise<void>} promise that will be resolved if the deletion is
     *                         successful or rejected in case of failure
     */
    deleteStatements(subject?: string, predicate?: string, object?: string, contexts?: String[] | string): Promise<void>;
    /**
     * Deletes all statements in the repository.
     *
     * @return {Promise<void>} promise that will be resolved if the deletion is
     *                   successful or rejected in case of failure
     */
    deleteAllStatements(): Promise<void>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The request is configured so that expected response should be a readable
     * stream.
     *
     * Provided request params will be automatically converted to N-Triples if
     * they are not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding request params
     *
     * @return {Promise<WritableStream>} the client can subscribe to the readable
     * stream events and consume the emitted strings depending on the provided
     * response type as soon as they are available.
     */
    download(payload: GetStatementsPayload): Promise<WritableStream>;
    /**
     * Executes a POST request against the <code>/statements</code> endpoint. The
     * statements which have to be added are provided through a readable stream.
     * This method is useful for library client who wants to upload a big data set
     * into the repository.
     *
     * @param {ReadableStream} readStream
     * @param {string} contentType is one of RDF mime type formats,
     *                application/x-rdftransaction' for a transaction document or
     *                application/x-www-form-urlencoded
     * @param {NamedNode|string} [context] optional context to restrict the
     * operation. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] optional uri against which any relative URIs
     * found in the data would be resolved.
     *
     * @return {Promise<void>} a promise that will be resolved when the stream has
     * been successfully consumed by the server
     */
    upload(readStream: ReadableStream, contentType: string, context?: NamedNode | string, baseURI?: string): Promise<void>;
    /**
     * Executes a PUT request against the <code>/statements</code> endpoint. The
     * statements which have to be updated are provided through a readable stream.
     * This method is useful for overriding large set of statements that might be
     * provided as a readable stream e.g. reading from file.
     *
     * @param {ReadableStream} readStream
     * @param {string} contentType
     * @param {NamedNode|string} context restrict the operation. Will be encoded
     * as N-Triple if it is not already one
     * @param {string} [baseURI] optional uri against which any relative URIs
     * found in the data would be resolved.
     *
     * @return {Promise<void>} a promise that will be resolved when the stream has
     * been successfully consumed by the server
     */
    overwrite(readStream: ReadableStream, contentType: string, context: NamedNode | string, baseURI?: string): Promise<void>;
    /**
     * Uploads the file specified by the provided file path to the server.
     *
     * See {@link #upload}
     *
     * @param {string} filePath path to a file to be streamed to the server
     * @param {string} contentType MIME type of the file's content
     * @param {string|string[]} [context] restricts the operation to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {Promise<void>} a promise that will be resolved when the file has
     * been successfully consumed by the server
     */
    addFile(filePath: string, contentType: string, context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Uploads the file specified by the provided file path to the server
     * overwriting any data in the server's repository.
     *
     * The overwrite will be restricted if the context parameter is specified.
     *
     * See {@link #overwrite}
     *
     * @param {string} filePath path to a file to be streamed to the server
     * @param {string} contentType MIME type of the file's content
     * @param {string} [context] restricts the operation to the given context.
     * Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {Promise<void>} a promise that will be resolved when the file has
     * been successfully consumed by the server
     */
    putFile(filePath: string, contentType: string, context?: string, baseURI?: string): Promise<void>;
    /**
     * Starts a transaction and produces a {@link TransactionalRepositoryClient}.
     *
     * The transactions ID is extracted from the <code>location</code> header and
     * is used as  endpoint for the produced TransactionalRepositoryClient.
     *
     * If no transaction isolation level is provided, the server will use its
     * default isolation level.
     *
     * @param {string} [isolationLevel] an optional parameter to specify the
     * transaction's level of isolation; for possible values  see
     * {@link TransactionIsolationLevel}
     * @return {Promise<TransactionalRepositoryClient>} transactional client
     */
    beginTransaction(isolationLevel?: string): Promise<TransactionalRepositoryClient>;
}

/**
 * @param {string[]} [endpoints] is an array with repository endpoints
 * @param {Object} [headers] is a key:value mapping of http headers and values
 * @param {string} [defaultRDFMimeType] one of {@link RDFMimeType} values
 * @param {number} [readTimeout]
 * @param {number} [writeTimeout]
 */
declare class RepositoryClientConfig {
    constructor(endpoints?: string[], headers?: any, defaultRDFMimeType?: string, readTimeout?: number, writeTimeout?: number);
    /**
     * Sets the repository endpoint URLs.
     *
     * @param {string[]} endpoints the endpoint URLs
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */
    setEndpoints(endpoints: string[]): RepositoryClientConfig;
    /**
     * Inserts a repository endpoint URL to the rest of the endpoints.
     *
     * @param {string} endpoint repository endpoint URL
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */
    addEndpoint(endpoint: string): RepositoryClientConfig;
    /**
     * Gets the repository endpoint URLs.
     *
     * @return {string[]}
     */
    getEndpoints(): string[];
    /**
     * Sets the default headers map for each HTTP request.
     *
     * @param {Object<string, string>} headers the map of default headers
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */
    setHeaders(headers: {
        [key: string]: string;
    }): RepositoryClientConfig;
    /**
     * Returns the default headers map for each HTTP request.
     *
     * @return {Object<string, string>}
     */
    getHeaders(): {
        [key: string]: string;
    };
    /**
     * Sets the default RDF MIME type.
     *
     * @param {string} defaultRDFMimeType
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */
    setDefaultRDFMimeType(defaultRDFMimeType: string): RepositoryClientConfig;
    /**
     * Returns the default RDF MIME type.
     *
     * @return {string}
     */
    getDefaultRDFMimeType(): string;
    /**
     * Sets the default read timeout for HTTP requests.
     *
     * @param {number} readTimeout the timeout in milliseconds
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */
    setReadTimeout(readTimeout: number): RepositoryClientConfig;
    /**
     * Returns the default read timeout for HTTP requests.
     *
     * @return {number}
     */
    getReadTimeout(): number;
    /**
     * Sets the default write timeout for HTTP requests.
     *
     * @param {number} writeTimeout the timeout in milliseconds
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */
    setWriteTimeout(writeTimeout: number): RepositoryClientConfig;
    /**
     * Returns the default write timeout for HTTP requests.
     *
     * @return {number}
     */
    getWriteTimeout(): number;
}

/**
 * Instantiates new statement payload.
 */
declare class StatementPayload {
    /**
     * @param {string} [subject]
     * @return {StatementPayload}
     */
    setSubject(subject?: string): StatementPayload;
    /**
     * @return {string} subject
     */
    getSubject(): string;
    /**
     * @param {string} [predicate]
     * @return {StatementPayload}
     */
    setPredicate(predicate?: string): StatementPayload;
    /**
     * @return {string} predicate
     */
    getPredicate(): string;
    /**
     * @param {string} [object]
     * @return {StatementPayload}
     */
    setObject(object?: string): StatementPayload;
    /**
     * @return {string} object
     */
    getObject(): string;
    /**
     * @param {(string|string[])} [context]
     * @return {StatementPayload}
     */
    setContext(context?: string | string[]): StatementPayload;
    /**
     * @return {string} context
     */
    getContext(): string;
    /**
     * Get the payload object.
     * @return {Object}
     */
    get(): any;
}

/**
 * @param {BaseRepositoryClient} repository
 * @param {number} total
 * @param {number} offset
 * @param {number} limit
 * @param {RDFMimeType} responseType
 * @param {(string|sparql|ResponseIterator)} result
 */
declare class PagedResponse {
    constructor(repository: BaseRepositoryClient, total: number, offset: number, limit: number, responseType: RDFMimeType, result: string | sparql | ResponseIterator);
}

/**
 * Defines a wrapper around chunked response allowing consuming the response
 * on demand.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class ResponseIterator {
}

/**
 * @param {string} [endpoint] Endpoint url.
 * @param {number} [timeout] Specifies the number of milliseconds before the
 *                         request times out.
 * @param {Map<string, string>} [headers] An http headers map.
 */
declare class ServerClientConfig {
    constructor(endpoint?: string, timeout?: number, headers?: Map<string, string>);
    /**
     * Sets the server's endpoint URL.
     *
     * @param {string} endpoint the endpoint URL
     *
     * @return {ServerClientConfig} the current config for method chaining
     */
    setEndpoint(endpoint: string): ServerClientConfig;
    /**
     * Returns the server's endpoint URL.
     *
     * @return {string} the endpoint URL
     */
    getEndpoint(): string;
    /**
     * Sets the default headers map for each HTTP request.
     *
     * @param {Object<string, string>} headers the default headers
     *
     * @return {ServerClientConfig} the current config for method chaining
     */
    setHeaders(headers: {
        [key: string]: string;
    }): ServerClientConfig;
    /**
     * Returns the default headers for each HTTP request.
     *
     * @return {Object<string, string>} the default headers map
     */
    getHeaders(): {
        [key: string]: string;
    };
    /**
     * Sets the timeout for HTTP requests.
     *
     * @param {number} timeout the timeout in milliseconds
     *
     * @return {ServerClientConfig} the current config for method chaining
     */
    setTimeout(timeout: number): ServerClientConfig;
    /**
     * Returns the HTTP requests's timeout.
     *
     * @return {number} the timeout in milliseconds
     */
    getTimeout(): number;
}

/**
 * @param {ServerClientConfig} config for the server client.
 *
 */
declare class ServerClient {
    constructor(config: ServerClientConfig);
    /**
     * Get an array of repository ids available in the server.
     * @return {Promise} promise which resolves with an Array with repository ids.
     */
    getRepositoryIDs(): Promise;
    /**
     * Check if repository with the provided id exists.
     * @param {string} id of the repository which should be checked.
     * @return {Promise<boolean>} promise which resolves with boolean value.
     */
    hasRepository(id: string): Promise<boolean>;
    /**
     * Creates a repository client instance with the provided id and
     * configuration.
     * @param {string} id of the repository
     * @param {RepositoryClientConfig} config for the overridable repository
     *    configuration.
     * @return {Promise<RDFRepositoryClient>} promise which resolves with
     *    new RDFRepositoryClient instance.
     */
    getRepository(id: string, config: RepositoryClientConfig): Promise<RDFRepositoryClient>;
    /**
     * Delete repository with the provided id.
     * @param {string} id of the repository which should be deleted.
     * @return {Promise<any>} promise which resolves with the delete result.
     */
    deleteRepository(id: string): Promise<any>;
    /**
     * Initializes the http client.
     */
    initHttpClient(): void;
    /**
     * Initializes the logger.
     */
    initLogger(): void;
}

/**
 * Service for downloading data via {@link GetStatementsPayload}.
 *
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class DownloadService {
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The request is configured so that expected response should be a readable
     * stream.
     *
     * Provided request params will be automatically converted to N-Triples if
     * they are not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding request params
     *
     * @return {ServiceRequest} a service request that will resolve to a readable
     * stream to which the client can subscribe and consume the emitted strings
     * depending on the provided response type as soon as they are available.
     */
    download(payload: GetStatementsPayload): ServiceRequest;
    /**
     * @inheritDoc
     */
    getServiceName(): void;
}

/**
 * Service for namespace management.
 *
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class NamespaceService {
    /**
     * Retrieves all present namespaces as a collection of {@link Namespace}.
     *
     * @return {ServiceRequest} a service request resolving to a collection of
     * {@link Namespace}
     */
    getNamespaces(): ServiceRequest;
    /**
     * Retrieves the namespace for the given prefix as {@link NamedNode}.
     *
     * For example if <code>rdfs</code> is provided as prefix that would result in
     * a {@link NamedNode} corresponding to following namespace:
     * <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     *
     * @param {string} prefix prefix of the namespace to be retrieved
     *
     * @return {ServiceRequest} service request resolving to {@link NamedNode}
     *
     * @throws {Error} if the prefix parameter is not supplied
     */
    getNamespace(prefix: string): ServiceRequest;
    /**
     * Creates or updates the namespace for the given prefix.
     *
     * If the provided prefix or namespace parameter is not a string or
     * {@link NamedNode} then the method will throw an error.
     *
     * @param {string} prefix prefix of the namespace to be created/updated
     * @param {string|NamedNode} namespace the namespace to be created/updated
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * create/update request is successful
     *
     * @throws {Error} if the prefix or namespace parameter are not provided
     */
    saveNamespace(prefix: string, namespace: string | NamedNode): ServiceRequest;
    /**
     * Deletes a namespace that corresponds to the given prefix.
     *
     * For example if <code>rdfs</code> is provided as prefix that would delete
     * the following namespace: <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     *
     * @param {string} prefix prefix of the namespace to be deleted
     *
     * @return {Promise<void>} promise that will be resolved if the deletion is
     * successful
     *
     * @throws {Error} if the prefix parameter is not provided
     */
    deleteNamespace(prefix: string): Promise<void>;
    /**
     * Deletes all namespace declarations in the repository.
     *
     * @return {Promise<void>} promise that will be resolved after
     * successful deletion
     */
    deleteNamespaces(): Promise<void>;
    /**
     * @inheritDoc
     */
    getServiceName(): void;
}

/**
 * Instantiates the query service.
 *
 * @param {Function} httpRequestExecutor used to execute HTTP requests
 * @param {Function} parseExecutor function that will parse provided data
 */
declare class QueryService {
    constructor(httpRequestExecutor: (...params: any[]) => any, parseExecutor: (...params: any[]) => any);
    /**
     * Executes request to query a repository.
     *
     * Only POST request with a valid QueryPayload is supported.
     *
     * @param {GetQueryPayload} payload is an object holding request parameters
     * required by the query POST endpoint.
     *
     * @return {ServiceRequest} a service request that will resolve to a readable
     * stream to which the client can subscribe and consume
     * the emitted strings or Quads depending on the provided response type as
     * soon as they are available.
     *
     * @throws {Error} if the payload is misconfigured
     */
    query(payload: GetQueryPayload): ServiceRequest;
    /**
     * Executes a request with a sparql query against <code>/statements</code>
     * endpoint to update repository data.
     *
     * If <code>contentType</code> is set to
     * <code>application/x-www-form-urlencoded</code> then query and request
     * parameters from the payload are encoded as query string and sent as request
     * body.
     *
     * If <code>contentType</code> is set to
     * <code>application/sparql-update</code> then the query is sent unencoded as
     * request body.
     *
     * @param {UpdateQueryPayload} payload
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * update is successful or rejected in case of failure
     *
     * @throws {Error} if the payload is misconfigured
     */
    update(payload: UpdateQueryPayload): ServiceRequest;
    /**
     * @inheritDoc
     */
    getServiceName(): void;
}

/**
 * Service for working repositories.
 *
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class RepositoryService {
    /**
     * Retrieves the size of the repository.
     *
     * Effectively returns how much statements are in the repository.
     *
     * If one or multiple context are provided, the operation will be restricted
     * upon each of them.
     *
     * @param {string|string[]} [context] context or contexts to restrict the
     * size calculation. Will be encoded as N-Triple if it is not already one
     *
     * @return {ServiceRequest} a service request resolving to the total number of
     * statements in the repository
     */
    getSize(context?: string | string[]): ServiceRequest;
    /**
     * @inheritDoc
     */
    getServiceName(): void;
}

/**
 * Defines a path segment for statements REST endpoint
 *
 * @type {string}
 */
declare const PATH_STATEMENTS = "/statements";

/**
 * Defines the path segment for namespaces REST endpoint
 *
 * @type {string}
 */
declare const PATH_NAMESPACES = "/namespaces";

/**
 * Defines a path segment for transactions REST endpoint.
 *
 * @type {string}
 */
declare const PATH_TRANSACTIONS = "/transactions";

/**
 * Defines a path segment for size REST endpoint.
 *
 * @type {string}
 */
declare const PATH_SIZE = "/size";

/**
 * Instantiates the request with the supplied builder and executor.
 *
 * @param {HttpRequestBuilder} httpRequestBuilder builder carrying
 * the request data and params
 * @param {Function} requestExecutor executor for HTTP requests
 */
declare class ServiceRequest {
    constructor(httpRequestBuilder: HttpRequestBuilder, requestExecutor: (...params: any[]) => any);
    /**
     * Returns the request builder.
     *
     * @return {HttpRequestBuilder}
     */
    getHttpRequestBuilder(): HttpRequestBuilder;
    /**
     * Triggers service request execution.
     *
     * @return {Promise}
     */
    execute(): Promise;
}

/**
 * Instantiates the service with the provided HTTP request executor function.
 *
 * @param {Function} httpRequestExecutor used to execute HTTP requests
 */
declare class Service {
    constructor(httpRequestExecutor: (...params: any[]) => any);
    /**
     * Returns the service's name.
    
     * @abstract
     *
     * @return {string} the name
     */
    getServiceName(): string;
}

/**
 * Instantiates the service with the supplied executor and parser utils.
 *
 * @param {Function} httpRequestExecutor executor for HTTP requests
 * @param {ParserRegistry} parserRegistry registry of available parsers
 * @param {Function} parseExecutor function that will parse provided data
 */
declare class StatementsService {
    constructor(httpRequestExecutor: (...params: any[]) => any, parserRegistry: ParserRegistry, parseExecutor: (...params: any[]) => any);
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding the request
     * parameters.
     *
     * @return {ServiceRequest} service request that resolves to plain string or
     * Quad according to provided response type.
     */
    get(payload: GetStatementsPayload): ServiceRequest;
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     *
     * @param {AddStatementPayload} payload holding request parameters
     *
     * @return {ServiceRequest} service request that will resolve if the addition
     * is successful or reject in case of failure
     *
     * @throws {Error} if the payload is not provided or the payload has null
     * subject, predicate and/or object
     */
    add(payload: AddStatementPayload): ServiceRequest;
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle/Trig text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * addition is successful or rejected in case of failure
     *
     * @throws {Error} if no quads are provided or if they cannot be converted
     */
    addQuads(quads: Quad[], context?: string | string[], baseURI?: string): ServiceRequest;
    /**
     * Overwrites the repository's data by serializing the provided quads to
     * Turtle format and sending them to the repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * The overwrite will be restricted if the context parameter is specified.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle/Trig text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * overwrite is successful or rejected in case of failure
     *
     * @throws {Error} if no quads are provided or if they cannot be converted
     */
    putQuads(quads: Quad[], context?: string | string[], baseURI?: string): ServiceRequest;
    /**
     * Deletes statements in the repository based on the provided subject,
     * predicate, object and or contexts. Each of them is optional and acts as
     * statements filter which effectively narrows the scope of the deletion.
     *
     * Providing context or contexts will restricts the operation to one or more
     * specific contexts in the repository.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     *
     * @param {String} [subject] resource subject
     * @param {String} [predicate] resource predicate
     * @param {String} [object] resource object
     * @param {String[]|String} [contexts] resource or resources context
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * deletion is successful or rejected in case of failure
     */
    deleteStatements(subject?: string, predicate?: string, object?: string, contexts?: String[] | string): ServiceRequest;
    /**
     * Deletes all statements in the repository.
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * deletion is successful or rejected in case of failure
     */
    deleteAllStatements(): ServiceRequest;
    /**
     * @inheritDoc
     */
    getServiceName(): void;
}

/**
 * Instantiates the transaction service wioth the supplied executor and
 * repository client config.
 *
 * @param {Function} httpRequestExecutor used to execute HTTP requests
 * @param {RepositoryClientConfig} repositoryClientConfig used to create
 * transaction client configurations
 */
declare class TransactionService {
    constructor(httpRequestExecutor: (...params: any[]) => any, repositoryClientConfig: RepositoryClientConfig);
    /**
     * Starts a transaction and produces a {@link TransactionalRepositoryClient}.
     *
     * The transactions ID is extracted from the <code>location</code> header and
     * is used as  endpoint for the produced TransactionalRepositoryClient.
     *
     * If no transaction isolation level is provided, the server will use its
     * default isolation level.
     *
     * @param {string} [isolationLevel] an optional parameter to specify the
     * transaction's level of isolation; for possible values see
     * {@link TransactionIsolationLevel}
     *
     * @return {Promise<TransactionalRepositoryClient>} transactional client
     */
    beginTransaction(isolationLevel?: string): Promise<TransactionalRepositoryClient>;
    /**
     * @inheritDoc
     */
    getServiceName(): void;
}

/**
 * Service for uploading data streams.
 *
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class UploadService {
    /**
     * Executes a POST request against the <code>/statements</code> endpoint. The
     * statements which have to be added are provided through a readable stream.
     * This method is useful for library client who wants to upload a big data set
     * into the repository.
     *
     * @param {ReadableStream} readStream
     * @param {string} contentType is one of RDF mime type formats,
     *                application/x-rdftransaction' for a transaction document or
     *                application/x-www-form-urlencoded
     * @param {NamedNode|string} [context] optional context to restrict the
     * operation. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] optional uri against which any relative URIs
     * found in the data would be resolved.
     *
     * @return {ServiceRequest} a service request that will be resolved when the
     * stream has been successfully consumed by the server
     */
    upload(readStream: ReadableStream, contentType: string, context?: NamedNode | string, baseURI?: string): ServiceRequest;
    /**
     * Executes a PUT request against the <code>/statements</code> endpoint. The
     * statements which have to be updated are provided through a readable stream.
     * This method is useful for overriding large set of statements that might be
     * provided as a readable stream e.g. reading from file.
     *
     * @param {ReadableStream} readStream
     * @param {string} contentType
     * @param {NamedNode|string} context restrict the operation. Will be encoded
     * as N-Triple if it is not already one
     * @param {string} [baseURI] optional uri against which any relative URIs
     * found in the data would be resolved.
     *
     * @return {ServiceRequest} a service request that will be resolved when the
     * stream has been successfully consumed by the server
     */
    overwrite(readStream: ReadableStream, contentType: string, context: NamedNode | string, baseURI?: string): ServiceRequest;
    /**
     * Uploads the file specified by the provided file path to the server.
     *
     * See {@link #upload}
     *
     * @param {string} filePath path to a file to be streamed to the server
     * @param {string} contentType MIME type of the file's content
     * @param {string|string[]} [context] restricts the operation to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {ServiceRequest} a service request that will be resolved when the
     * file has been successfully consumed by the server
     */
    addFile(filePath: string, contentType: string, context?: string | string[], baseURI?: string): ServiceRequest;
    /**
     * Uploads the file specified by the provided file path to the server
     * overwriting any data in the server's repository.
     *
     * The overwrite will be restricted if the context parameter is specified.
     *
     * See {@link #overwrite}
     *
     * @param {string} filePath path to a file to be streamed to the server
     * @param {string} contentType MIME type of the file's content
     * @param {string} [context] restricts the operation to the given context.
     * Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {ServiceRequest} a service request that will be resolved when the
     * file has been successfully consumed by the server
     */
    putFile(filePath: string, contentType: string, context?: string, baseURI?: string): ServiceRequest;
    /**
     * @inheritDoc
     */
    getServiceName(): void;
}

/**
 * Supported transaction levels.
 *
 * @readonly
 * @enum {string}
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare const enum TransactionIsolationLevel {
    NONE = "NONE",
    READ_UNCOMMITTED = "READ_UNCOMMITTED",
    READ_COMMITTED = "READ_COMMITTED",
    SNAPSHOT_READ = "SNAPSHOT_READ",
    SNAPSHOT = "SNAPSHOT",
    SERIALIZABLE = "SERIALIZABLE"
}

/**
 * @param {RepositoryClientConfig} repositoryClientConfig
 */
declare class TransactionalRepositoryClient {
    constructor(repositoryClientConfig: RepositoryClientConfig);
    /**
     * @inheritDoc
     */
    getLogger(): void;
    /**
     * Instantiates dependent services.
     */
    initServices(): void;
    /**
     * @inheritDoc
     * @override
     * @throws {Error} if the transaction has been committed or rollbacked
     */
    execute(): void;
    /**
     * Updates the http request builder in the provided service request for
     * executing requests in a transaction.
     *
     * @param {ServiceRequest} serviceRequest the request to mutate
     * @param {string} action the transaction action
     */
    decorateServiceRequest(serviceRequest: ServiceRequest, action: string): void;
    /**
     * Retrieves the size of the repository during the transaction and its
     * isolation level.
     *
     * Repository size is the amount of statements present.
     *
     * @param {string|string[]} [context] if provided, the size calculation will
     * be restricted. Will be encoded as N-Triple if it is not already one
     * @return {Promise<number>} a promise resolving to the size of the repo
     */
    getSize(context?: string | string[]): Promise<number>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The fetched data depends on the transaction isolation level.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding the request
     * parameters.
     * @return {Promise<string|Quad>} resolves with plain string or Quad according
     *      to provided response type.
     */
    get(payload: GetStatementsPayload): Promise<string | Quad>;
    /**
     * Executes request to query a repository.
     *
     * @param {GetQueryPayload} payload is an object holding request parameters
     *
     * @return {Promise} the client can subscribe to the stream events and consume
     * the emitted strings or Quads depending on the provided response type as
     * soon as they are available.
     * @throws {Error} if the payload is misconfigured
     */
    query(payload: GetQueryPayload): Promise;
    /**
     * Executes a request with a SPARQL query to update repository data.
     *
     * @param {UpdateQueryPayload} payload request object containing the query
     * @return {Promise<void>} promise that will be resolved if the update is
     * successful or rejected in case of failure
     * @throws {Error} if the payload is misconfigured
     */
    update(payload: UpdateQueryPayload): Promise<void>;
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     *
     * @param {AddStatementPayload} payload holding request parameters
     *
     * @return {Promise<void>} promise that will be resolved if the addition is
     * successful or rejected in case of failure
     * @throws {Error} if the payload is not provided or the payload has null
     * subject, predicate and/or object
     */
    add(payload: AddStatementPayload): Promise<void>;
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     * @return {Promise<void>} promise that will be resolved if the addition
     * is successful or rejected in case of failure
     */
    addQuads(quads: Quad[], context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Deletes the statements in the provided Turtle or Trig formatted data.
     *
     * @param {string} data payload data in Turtle or Trig format
     * @return {Promise<void>} promise resolving after the data has been deleted
     * successfully
     * @throws {Error} if no data is provided for deleting
     */
    deleteData(data: string): Promise<void>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The request is configured so that expected response should be a readable
     * stream.
     *
     * Provided request params will be automatically converted to N-Triples if
     * they are not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding request params
     *
     * @return {Promise<WritableStream>} the client can subscribe to the readable
     * stream events and consume the emitted strings depending on the provided
     * response type as soon as they are available.
     */
    download(payload: GetStatementsPayload): Promise<WritableStream>;
    /**
     * Streams data to the repository from the provided readable stream.
     *
     * This method is useful for library client who wants to upload a big data set
     * into the repository during a transaction
     *
     * @param {ReadableStream} readStream stream with the data to be uploaded
     * @param {string} contentType is one of RDF mime type formats,
     *                application/x-rdftransaction' for a transaction document or
     *                application/x-www-form-urlencoded
     * @param {NamedNode|string} [context] optional context to restrict the
     * operation. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] optional uri against which any relative URIs
     * found in the data would be resolved.
     *
     * @return {Promise<void>} a promise that will be resolved when the stream has
     * been successfully consumed by the server
     */
    upload(readStream: ReadableStream, contentType: string, context?: NamedNode | string, baseURI?: string): Promise<void>;
    /**
     * Uploads the file specified by the provided file path to the server.
     *
     * See {@link #upload}
     *
     * @param {string} filePath path to a file to be streamed to the server
     * @param {string} contentType MIME type of the file's content
     * @param {string|string[]} [context] restricts the operation to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {Promise<void>} a promise that will be resolved when the file has
     * been successfully consumed by the server
     */
    addFile(filePath: string, contentType: string, context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Commits the current transaction by applying any changes that have been
     * sent to the server.
     *
     * This effectively makes the transaction inactive.
     *
     * @return {Promise<void>} that will be resolved after successful commit
     */
    commit(): Promise<void>;
    /**
     * Rollbacks the current transaction reverting any changes in the server.
     *
     * This effectively makes the transaction inactive.
     *
     * @return {Promise<void>} that will be resolved after successful rollback
     */
    rollback(): Promise<void>;
    /**
     * @return {boolean} <code>true</code> if the transaction is active or
     * <code>false</code> otherwise
     */
    isActive(): boolean;
}

/**
 * Common utility functions.
 *
 * @class
 * @author Mihail Radkov
 */
declare class CommonUtils {
    /**
     * Checks if at least one of the supplied arguments is undefined or null.
     *
     * @return {boolean} <code>true</code> if there is null argument or
     *         <code>false</code> otherwise
     */
    static hasNullArguments(): boolean;
}

/**
 * Utilities related to working with files and the file system.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class FileUtils {
    /**
     * Opens a readable stream from a file located at the provided file path.
     *
     * If the file path is blank or points to non existent file, the method will
     * result in an error.
     *
     * @param {string} filePath path to the file to be read
     * @return {ReadableStream} stream with the file data
     * @throws {Error} if the file path is not provided or no file exists for it
     */
    static getReadStream(filePath: string): ReadableStream;
}

/**
 * Constructs new iterable for the provided collection.
 *
 * @param {Object[]} iterable the collection to iterate
 */
declare class Iterable {
    constructor(iterable: object[]);
    /**
     * Returns if there are elements left to be iterated from the collection.
     *
     * Use this method before calling {@link next()} to avoid out of bounds error.
     *
     * @return {boolean} <code>true</code> if there is at least single element
     *                    left to iterate or <code>false</code> otherwise
     */
    hasNext(): boolean;
    /**
     * Returns the next object from the iterable collection.
     *
     * Before invoking this method, check if there are elements to iterate by
     * using {@link hasNext()} because if there are no objects left to iterate,
     * the function will blow with an error.
     *
     * @return {Object} the next iterated object from the collection
     * @throws {Error} if there are no more elements to be iterated
     */
    next(): any;
    /**
     * Resets the iterable to begin from the start as if it was just constructed.
     *
     * @return {Iterable} the current iterable for method chaining.
     */
    reset(): Iterable;
}

/**
 * Class with utility methods related to strings.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class StringUtils {
    /**
     * Tells if the provided string is null or blank ignoring
     * whitespace characters.
     *
     * @param {string} string the string to check
     * @return {boolean} <code>true</code> if the string is blank or
     *                    <code>false</code> otherwise
     */
    static isBlank(string: string): boolean;
    /**
     * Tells if the provided string is NOT null and NOT blank ignoring
     * whitespace characters.
     *
     * @param {string} string the string to check
     * @return {boolean} <code>true</code> if the string is not blank or
     *                    <code>false</code> otherwise
     */
    static isNotBlank(string: string): boolean;
}

