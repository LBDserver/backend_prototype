"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ContentParser = require('../parser/content-parser');

var ConsoleLogger = require('../logging/console-logger');
/**
 * Implementation of registry holding {@link ContentParser} instances and
 * providing interface for registration and access.
 * If this registry is not provided with a list with parsers then it is
 * initialized empty. Otherwise provided parsers are validated if they are
 * compatible with the {@link ContentParser} interface and an error is
 * thrown if there are invalid parsers.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */


var ParserRegistry =
/*#__PURE__*/
function () {
  /**
   * @param {ContentParser[]} [parsers] initialized list with valid parser
   * instances.
   */
  function ParserRegistry() {
    var parsers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, ParserRegistry);

    this.parsers = {};
    this.initLogger();
    this.validateParsers(parsers);
    this.init(parsers);
  }
  /**
   * Initializes a console logger.
   */


  _createClass(ParserRegistry, [{
    key: "initLogger",
    value: function initLogger() {
      this.logger = new ConsoleLogger({
        name: 'ParserRegistry'
      });
    }
    /**
     * Register provided {@link ContentParser} under given key as returned by
     * <code>parser.getSupportedType()</code>.
     * If the type of the provided parser is already registered, then this method
     * will override the registered parser with the provided instance.
     *
     * @param {ContentParser} parser implementation wrapper.
     */

  }, {
    key: "register",
    value: function register(parser) {
      ParserRegistry.validateParser(parser);
      var supportedType = parser.getSupportedType();

      if (this.parsers[supportedType]) {
        this.logger.warn({
          parserType: supportedType
        }, 'Overriding registered parser');
      }

      this.parsers[parser.getSupportedType()] = parser;
    }
    /**
     * Getter for parser of given type.
     *
     * @param {string} type of the parser for get.
     * @return {ContentParser} if parser of requested type is found or
     * <code>null</code> otherwise.
     */

  }, {
    key: "get",
    value: function get(type) {
      return this.parsers[type];
    }
    /**
     * Maps provided parsers by their supported content type.
     *
     * @private
     * @param {ContentParser[]} parsers provided with the constructor.
     */

  }, {
    key: "init",
    value: function init(parsers) {
      var _this = this;

      parsers.forEach(function (parser) {
        _this.parsers[parser.getSupportedType()] = parser;
      });
    }
    /**
     * @private
     * @param {ContentParser[]} parsers
     */

  }, {
    key: "validateParsers",
    value: function validateParsers(parsers) {
      parsers.forEach(function (parser) {
        ParserRegistry.validateParser(parser);
      });
    }
    /**
     * @private
     * @param {ContentParser} parser to be validated
     * @throws {Error} if the provided parser is not implementing
     * {@link ContentParser} or has not supported type
     */

  }], [{
    key: "validateParser",
    value: function validateParser(parser) {
      if (!parser || !(parser instanceof ContentParser)) {
        throw new Error('Parser is not provided or does not implement' + ' ContentParser!');
      }

      if (!parser.getSupportedType()) {
        throw new Error('Parser type is mandatory parameter!');
      }
    }
  }]);

  return ParserRegistry;
}();

module.exports = ParserRegistry;