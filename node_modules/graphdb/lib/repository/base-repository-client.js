"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ParserRegistry = require('../parser/parser-registry');

var ConsoleLogger = require('../logging/console-logger');

var HttpClient = require('../http/http-client');

var RepositoryClientConfig = require('../repository/repository-client-config');

var Iterable = require('../util/iterable');

var HttpResponse = require('../http/http-response');

var LoggingUtils = require('../logging/logging-utils');
/**
 * Set of HTTP status codes for which requests could be re-attempted.
 *
 * @type {number[]}
 */


var RETRIABLE_STATUSES = [503 // Server busy
];
/**
 * Implementation of the RDF repository operations.
 *
 * The repository will construct a list of HTTP clients for each supplied
 * repository endpoint in the configuration. These clients will be used as
 * fallback strategy.
 *
 * @abstract
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */

var BaseRepositoryClient =
/*#__PURE__*/
function () {
  /**
   * Constructs a repository client with the provided configuration.
   *
   * @param {RepositoryClientConfig} repositoryClientConfig
   */
  function BaseRepositoryClient(repositoryClientConfig) {
    _classCallCheck(this, BaseRepositoryClient);

    BaseRepositoryClient.validateConfig(repositoryClientConfig);
    this.repositoryClientConfig = repositoryClientConfig;
    this.initParsers();
    this.initLogger();
    this.initHttpClients();
  }
  /**
   * Initializes the parser registry with default supported parsers.
   * @private
   */


  _createClass(BaseRepositoryClient, [{
    key: "initParsers",
    value: function initParsers() {
      this.parserRegistry = new ParserRegistry();
    }
    /**
     * Initializes a logger instance.
     * @private
     */

  }, {
    key: "initLogger",
    value: function initLogger() {
      this.logger = this.getLogger();
    }
    /**
     * Gets a logger instance.
     *
     * @return {Logger} the logger instance
     */

  }, {
    key: "getLogger",
    value: function getLogger() {
      return new ConsoleLogger();
    }
    /**
     * Initializes http clients depending on the provided endpoints.
     * @private
     */

  }, {
    key: "initHttpClients",
    value: function initHttpClients() {
      var config = this.repositoryClientConfig; // Constructs a http client for each endpoint

      this.httpClients = config.getEndpoints().map(function (endpoint) {
        return new HttpClient(endpoint).setDefaultHeaders(config.getHeaders()).setDefaultReadTimeout(config.getReadTimeout()).setDefaultWriteTimeout(config.getWriteTimeout());
      });
    }
    /**
     * Register provided parser in the internal parser registry.
     *
     * @param {ContentParser} parser implementation wrapper.
     */

  }, {
    key: "registerParser",
    value: function registerParser(parser) {
      this.parserRegistry.register(parser);
    }
    /**
     * Parses provided content with registered parser if there is one. Otherwise
     * returns the content untouched. If <code>contentType</code> is provided it
     * should be an instance of {@link RDFMimeType} enum and is used as a key
     * for selecting appropriate parser from the parsers registry.
     * Parsing is done synchronously!
     *
     * @protected
     * @param {string} content
     * @param {string} responseType
     * @param {Object} [parserConfig] optional parser configuration
     * @return {(string|Term|Term[])}
     */

  }, {
    key: "parse",
    value: function parse(content, responseType) {
      var parserConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!this.parserRegistry.get(responseType)) {
        return content;
      }

      var parser = this.parserRegistry.get(responseType);
      var startTime = Date.now();
      var parsed = parser.parse(content, parserConfig);
      var elapsedTime = Date.now() - startTime;
      this.logger.debug({
        elapsedTime: elapsedTime,
        responseType: responseType
      }, 'Parsed content');
      return parsed;
    }
    /**
     * Executor for http requests. It passes the provided HTTP request builder
     * to a HTTP client for executing requests.
     *
     * If the request was unsuccessful it will be retried with another endpoint
     * HTTP client in case the request's status is one of
     * {@link RETRIABLE_STATUSES} or if the host is currently unreachable.
     *
     * If all of the endpoints are unsuccessful then the execution will fail
     * with promise rejection.
     *
     * @protected
     * @param {HttpRequestBuilder} requestBuilder the http request data to be
     * passed to a http client
     * @return {Promise<HttpResponse|Error>} a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "execute",
    value: function execute(requestBuilder) {
      try {
        var startTime = Date.now();
        var httpClients = new Iterable(this.httpClients);
        return this.retryExecution(httpClients, requestBuilder).then(function (executionResponse) {
          executionResponse.setElapsedTime(Date.now() - startTime);
          return executionResponse;
        });
      } catch (err) {
        return Promise.reject(err);
      }
    }
    /**
     * Retries HTTP request execution until successful or until no more clients
     * are left if the status is allowed for retry.
     *
     * @private
     * @param {Iterable} httpClients iterable collection of http clients
     * @param {HttpRequestBuilder} requestBuilder the http request data to be
     * passed to a http client
     * @return {Promise<HttpResponse|Error>} a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */

  }, {
    key: "retryExecution",
    value: function retryExecution(httpClients, requestBuilder) {
      var _this = this;

      var httpClient = httpClients.next();
      return httpClient.request(requestBuilder).then(function (response) {
        return new HttpResponse(response, httpClient);
      })["catch"](function (error) {
        var canRetry = BaseRepositoryClient.canRetryExecution(error);
        var hasNext = httpClients.hasNext();
        var loggerPayload = {
          repositoryUrl: httpClient.getBaseURL()
        }; // Try the next repo http client (if any)

        if (canRetry && hasNext) {
          _this.logger.warn(loggerPayload, 'Retrying execution');

          return _this.retryExecution(httpClients, requestBuilder);
        }

        if (!canRetry) {
          _this.logger.error(loggerPayload, 'Cannot retry execution');
        } else {
          _this.logger.error(loggerPayload, 'No more retries');
        } // Not retriable


        return Promise.reject(error);
      });
    }
    /**
     * Creates an object from the provided HTTP response that is suitable for
     * structured logging.
     *
     * Any additional key-value entries from <code>params</code> will be assigned
     * in the created payload object.
     *
     * @protected
     * @param {HttpResponse} response the HTTP response.
     * Used to get the execution time and the base URL
     * @param {object} [params] additional parameters to be appended
     * @return {object} the constructed payload object for logging
     */

  }, {
    key: "getLogPayload",
    value: function getLogPayload(response, params) {
      return LoggingUtils.getLogPayload(response, params);
    }
    /**
     * Checks if the request that produced the provided error can be re-attempted.
     *
     * @private
     * @param {Object} error the error to check
     * @return {boolean} <code>true</code> if it can be attempted again or
     *                    <code>false</code> otherwise
     */

  }], [{
    key: "canRetryExecution",
    value: function canRetryExecution(error) {
      // Not an error from the HTTP client, do not retry
      if (!error || !error.request) {
        return false;
      } // The current client couldn't get a response from the server, try again


      if (!error.response) {
        return true;
      }

      var status = error.response.status;
      return RETRIABLE_STATUSES.indexOf(status) > -1;
    }
    /**
     * Validates the provided repository client configuration.
     *
     * @private
     * @param {RepositoryClientConfig} repositoryClientConfig the config to check
     * @throws {Error} if the configuration is not an instance of
     * {@link RepositoryClientConfig} or there are no configured endpoints
     */

  }, {
    key: "validateConfig",
    value: function validateConfig(repositoryClientConfig) {
      if (!(repositoryClientConfig instanceof RepositoryClientConfig)) {
        throw new Error('Cannot instantiate repository with unsupported config ' + 'type!');
      }

      var endpoints = repositoryClientConfig.getEndpoints();

      if (!endpoints || !endpoints.length) {
        throw new Error('Cannot instantiate a repository without repository ' + 'endpoint configuration! At least one endpoint must be provided.');
      }
    }
  }]);

  return BaseRepositoryClient;
}();

module.exports = BaseRepositoryClient;