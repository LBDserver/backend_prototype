"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Service = require('./service');

var HttpRequestBuilder = require('../http/http-request-builder');

var ServiceRequest = require('./service-request');

var PATH_NAMESPACES = require('./service-paths').PATH_NAMESPACES;

var RDFMimeType = require('../http/rdf-mime-type');

var Namespace = require('../model/namespace');

var LoggingUtils = require('../logging/logging-utils');

var StringUtils = require('../util/string-utils');

var DataFactory = require('n3').DataFactory;

var NamedNode = DataFactory.internal.NamedNode;
/**
 * Service for namespace management.
 *
 * @author Mihail Radkov
 * @author Svilen Velikov
 */

var NamespaceService =
/*#__PURE__*/
function (_Service) {
  _inherits(NamespaceService, _Service);

  function NamespaceService() {
    _classCallCheck(this, NamespaceService);

    return _possibleConstructorReturn(this, _getPrototypeOf(NamespaceService).apply(this, arguments));
  }

  _createClass(NamespaceService, [{
    key: "getNamespaces",

    /**
     * Retrieves all present namespaces as a collection of {@link Namespace}.
     *
     * @return {ServiceRequest} a service request resolving to a collection of
     * {@link Namespace}
     */
    value: function getNamespaces() {
      var _this = this;

      var requestBuilder = HttpRequestBuilder.httpGet(PATH_NAMESPACES).addAcceptHeader(RDFMimeType.SPARQL_RESULTS_JSON);
      return new ServiceRequest(requestBuilder, function () {
        return _this.httpRequestExecutor(requestBuilder).then(function (response) {
          _this.logger.debug(LoggingUtils.getLogPayload(response), 'Fetched namespaces');

          return _this.mapNamespaceResponse(response.getData());
        });
      });
    }
    /**
     * Maps the response data from the namespaces request into {@link Namespace}.
     *
     * @private
     *
     * @param {object} responseData the data to map
     *
     * @return {Namespace[]} the mapped namespaces
     */

  }, {
    key: "mapNamespaceResponse",
    value: function mapNamespaceResponse(responseData) {
      return responseData.results.bindings.map(function (binding) {
        var prefix = binding.prefix.value;
        var namespace = DataFactory.namedNode(binding.namespace.value);
        return new Namespace(prefix, namespace);
      });
    }
    /**
     * Retrieves the namespace for the given prefix as {@link NamedNode}.
     *
     * For example if <code>rdfs</code> is provided as prefix that would result in
     * a {@link NamedNode} corresponding to following namespace:
     * <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     *
     * @param {string} prefix prefix of the namespace to be retrieved
     *
     * @return {ServiceRequest} service request resolving to {@link NamedNode}
     *
     * @throws {Error} if the prefix parameter is not supplied
     */

  }, {
    key: "getNamespace",
    value: function getNamespace(prefix) {
      var _this2 = this;

      if (StringUtils.isBlank(prefix)) {
        throw new Error('Parameter prefix is required!');
      }

      var namespaceUrl = "".concat(PATH_NAMESPACES, "/").concat(prefix);
      var requestBuilder = HttpRequestBuilder.httpGet(namespaceUrl);
      return new ServiceRequest(requestBuilder, function () {
        return _this2.httpRequestExecutor(requestBuilder).then(function (response) {
          _this2.logger.debug(LoggingUtils.getLogPayload(response, {
            prefix: prefix
          }), 'Fetched namespace');

          return DataFactory.namedNode(response.getData());
        });
      });
    }
    /**
     * Creates or updates the namespace for the given prefix.
     *
     * If the provided prefix or namespace parameter is not a string or
     * {@link NamedNode} then the method will throw an error.
     *
     * @param {string} prefix prefix of the namespace to be created/updated
     * @param {string|NamedNode} namespace the namespace to be created/updated
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * create/update request is successful
     *
     * @throws {Error} if the prefix or namespace parameter are not provided
     */

  }, {
    key: "saveNamespace",
    value: function saveNamespace(prefix, namespace) {
      var _this3 = this;

      if (StringUtils.isBlank(prefix)) {
        throw new Error('Parameter prefix is required!');
      }

      var payload = namespace;

      if (namespace instanceof NamedNode) {
        payload = namespace.value;
      } else if (StringUtils.isBlank(namespace)) {
        throw new Error('Parameter namespace is required!');
      }

      var requestBuilder = HttpRequestBuilder.httpPut("".concat(PATH_NAMESPACES, "/").concat(prefix)).setData(payload);
      return new ServiceRequest(requestBuilder, function () {
        return _this3.httpRequestExecutor(requestBuilder).then(function (response) {
          _this3.logger.debug(LoggingUtils.getLogPayload(response, {
            prefix: prefix,
            namespace: namespace
          }), 'Saved namespace');
        });
      });
    }
    /**
     * Deletes a namespace that corresponds to the given prefix.
     *
     * For example if <code>rdfs</code> is provided as prefix that would delete
     * the following namespace: <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     *
     * @param {string} prefix prefix of the namespace to be deleted
     *
     * @return {Promise<void>} promise that will be resolved if the deletion is
     * successful
     *
     * @throws {Error} if the prefix parameter is not provided
     */

  }, {
    key: "deleteNamespace",
    value: function deleteNamespace(prefix) {
      var _this4 = this;

      if (StringUtils.isBlank(prefix)) {
        throw new Error('Parameter prefix is required!');
      }

      var requestBuilder = HttpRequestBuilder.httpDelete("".concat(PATH_NAMESPACES, "/").concat(prefix));
      return new ServiceRequest(requestBuilder, function () {
        return _this4.httpRequestExecutor(requestBuilder).then(function (response) {
          _this4.logger.debug(LoggingUtils.getLogPayload(response, {
            prefix: prefix
          }), 'Deleted namespace');
        });
      });
    }
    /**
     * Deletes all namespace declarations in the repository.
     *
     * @return {Promise<void>} promise that will be resolved after
     * successful deletion
     */

  }, {
    key: "deleteNamespaces",
    value: function deleteNamespaces() {
      var _this5 = this;

      var requestBuilder = HttpRequestBuilder.httpDelete(PATH_NAMESPACES);
      return new ServiceRequest(requestBuilder, function () {
        return _this5.httpRequestExecutor(requestBuilder).then(function (response) {
          _this5.logger.debug(LoggingUtils.getLogPayload(response), 'Deleted all namespaces');
        });
      });
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "getServiceName",
    value: function getServiceName() {
      return 'NamespaceService';
    }
  }]);

  return NamespaceService;
}(Service);

module.exports = NamespaceService;