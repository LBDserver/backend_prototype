"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Service = require('./service');

var HttpRequestBuilder = require('../http/http-request-builder');

var ServiceRequest = require('./service-request');

var PATH_STATEMENTS = require('./service-paths').PATH_STATEMENTS;

var RDFMimeType = require('../http/rdf-mime-type');

var StringUtils = require('../util/string-utils');

var TermConverter = require('../model/term-converter');

var LoggingUtils = require('../logging/logging-utils');

var CommonUtils = require('../util/common-utils');
/**
 * Service for reading, inserting or deleting repository statements.
 *
 * @author Mihail Radkov
 * @author Svilen Velikov
 */


var StatementsService =
/*#__PURE__*/
function (_Service) {
  _inherits(StatementsService, _Service);

  /**
   * Instantiates the service with the supplied executor and parser utils.
   *
   * @param {Function} httpRequestExecutor executor for HTTP requests
   * @param {ParserRegistry} parserRegistry registry of available parsers
   * @param {Function} parseExecutor function that will parse provided data
   */
  function StatementsService(httpRequestExecutor, parserRegistry, parseExecutor) {
    var _this;

    _classCallCheck(this, StatementsService);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StatementsService).call(this, httpRequestExecutor));
    _this.parserRegistry = parserRegistry;
    _this.parseExecutor = parseExecutor;
    return _this;
  }
  /**
   * Fetch rdf data from statements endpoint using provided parameters.
   *
   * Provided values will be automatically converted to N-Triples if they are
   * not already encoded as such.
   *
   * @param {GetStatementsPayload} payload is an object holding the request
   * parameters.
   *
   * @return {ServiceRequest} service request that resolves to plain string or
   * Quad according to provided response type.
   */


  _createClass(StatementsService, [{
    key: "get",
    value: function get(payload) {
      var _this2 = this;

      var requestBuilder = HttpRequestBuilder.httpGet(PATH_STATEMENTS).setParams({
        subj: TermConverter.toNTripleValue(payload.getSubject()),
        pred: TermConverter.toNTripleValue(payload.getPredicate()),
        obj: TermConverter.toNTripleValue(payload.getObject()),
        context: TermConverter.toNTripleValues(payload.getContext()),
        infer: payload.getInference()
      }).addAcceptHeader(payload.getResponseType());
      var parser = this.parserRegistry.get(payload.getResponseType());

      if (parser && parser.isStreaming()) {
        requestBuilder.setResponseType('stream');
      }

      return new ServiceRequest(requestBuilder, function () {
        return _this2.httpRequestExecutor(requestBuilder).then(function (response) {
          _this2.logger.debug(LoggingUtils.getLogPayload(response, {
            subject: payload.getSubject(),
            predicate: payload.getPredicate(),
            object: payload.getObject(),
            context: payload.getContext()
          }), 'Fetched data');

          return _this2.parseExecutor(response.getData(), payload.getResponseType());
        });
      });
    }
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     *
     * @param {AddStatementPayload} payload holding request parameters
     *
     * @return {ServiceRequest} service request that will resolve if the addition
     * is successful or reject in case of failure
     *
     * @throws {Error} if the payload is not provided or the payload has null
     * subject, predicate and/or object
     */

  }, {
    key: "add",
    value: function add(payload) {
      if (!payload) {
        throw new Error('Cannot add statement without payload');
      }

      var subject = payload.getSubject();
      var predicate = payload.getPredicate();
      var object = payload.getObject();
      var context = payload.getContext();

      if (CommonUtils.hasNullArguments(subject, predicate, object)) {
        throw new Error('Cannot add statement with null ' + 'subject, predicate or object');
      }

      var quads;

      if (payload.isLiteral()) {
        quads = TermConverter.getLiteralQuads(subject, predicate, object, context, payload.getDataType(), payload.getLanguage());
      } else {
        quads = TermConverter.getQuads(subject, predicate, object, context);
      }

      return this.addQuads(quads, payload.getContext(), payload.getBaseURI());
    }
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle/Trig text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * addition is successful or rejected in case of failure
     *
     * @throws {Error} if no quads are provided or if they cannot be converted
     */

  }, {
    key: "addQuads",
    value: function addQuads(quads, context, baseURI) {
      var _this3 = this;

      var requestBuilder = this.getInsertRequest(quads, context, baseURI, false);
      return new ServiceRequest(requestBuilder, function () {
        return _this3.httpRequestExecutor(requestBuilder).then(function (response) {
          _this3.logger.debug(LoggingUtils.getLogPayload(response, {
            quads: quads,
            context: context,
            baseURI: baseURI
          }), 'Inserted statements');
        });
      });
    }
    /**
     * Overwrites the repository's data by serializing the provided quads to
     * Turtle format and sending them to the repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * The overwrite will be restricted if the context parameter is specified.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle/Trig text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * overwrite is successful or rejected in case of failure
     *
     * @throws {Error} if no quads are provided or if they cannot be converted
     */

  }, {
    key: "putQuads",
    value: function putQuads(quads, context, baseURI) {
      var _this4 = this;

      var requestBuilder = this.getInsertRequest(quads, context, baseURI, true);
      return new ServiceRequest(requestBuilder, function () {
        return _this4.httpRequestExecutor(requestBuilder).then(function (response) {
          _this4.logger.debug(LoggingUtils.getLogPayload(response, {
            quads: quads,
            context: context,
            baseURI: baseURI
          }), 'Overwritten statements');
        });
      });
    }
    /**
     * Constructs HttpRequestBuilder from the provided parameters for saving or
     * overwriting statements.
     *
     * @private
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle/Trig text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     * @param {boolean} overwrite defines if the data should overwrite the repo
     * data or not
     *
     * @return {HttpRequestBuilder} promise resolving after the data has
     * been inserted successfully or an error if not
     *
     * @throws {Error} if no quads are provided or if they cannot be converted
     */

  }, {
    key: "getInsertRequest",
    value: function getInsertRequest(quads, context, baseURI, overwrite) {
      var converted = TermConverter.toString(quads);

      if (StringUtils.isBlank(converted)) {
        throw new Error('Turtle/trig data is required when adding statements');
      }

      var requestBuilder = new HttpRequestBuilder().setUrl(PATH_STATEMENTS).setData(converted).addContentTypeHeader(RDFMimeType.TRIG).setParams({
        baseURI: baseURI,
        context: TermConverter.toNTripleValues(context)
      });

      if (overwrite) {
        requestBuilder.setMethod('put');
      } else {
        requestBuilder.setMethod('post');
      }

      return requestBuilder;
    }
    /**
     * Deletes statements in the repository based on the provided subject,
     * predicate, object and or contexts. Each of them is optional and acts as
     * statements filter which effectively narrows the scope of the deletion.
     *
     * Providing context or contexts will restricts the operation to one or more
     * specific contexts in the repository.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     *
     * @param {String} [subject] resource subject
     * @param {String} [predicate] resource predicate
     * @param {String} [object] resource object
     * @param {String[]|String} [contexts] resource or resources context
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * deletion is successful or rejected in case of failure
     */

  }, {
    key: "deleteStatements",
    value: function deleteStatements(subject, predicate, object, contexts) {
      var _this5 = this;

      var requestBuilder = HttpRequestBuilder.httpDelete(PATH_STATEMENTS).setParams({
        subj: TermConverter.toNTripleValue(subject),
        pred: TermConverter.toNTripleValue(predicate),
        obj: TermConverter.toNTripleValue(object),
        context: TermConverter.toNTripleValues(contexts)
      });
      return new ServiceRequest(requestBuilder, function () {
        return _this5.httpRequestExecutor(requestBuilder).then(function (response) {
          _this5.logger.debug(LoggingUtils.getLogPayload(response, {
            subject: subject,
            predicate: predicate,
            object: object,
            contexts: contexts
          }), 'Deleted statements');
        });
      });
    }
    /**
     * Deletes all statements in the repository.
     *
     * @return {ServiceRequest} service request that will be resolved if the
     * deletion is successful or rejected in case of failure
     */

  }, {
    key: "deleteAllStatements",
    value: function deleteAllStatements() {
      var _this6 = this;

      var requestBuilder = HttpRequestBuilder.httpDelete(PATH_STATEMENTS);
      return new ServiceRequest(requestBuilder, function () {
        return _this6.httpRequestExecutor(requestBuilder).then(function (response) {
          _this6.logger.debug(LoggingUtils.getLogPayload(response), 'Deleted all statements');
        });
      });
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "getServiceName",
    value: function getServiceName() {
      return 'StatementsService';
    }
  }]);

  return StatementsService;
}(Service);

module.exports = StatementsService;